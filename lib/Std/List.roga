module Std.List {
  count, head, isEmpty, filter, groupBy, map, reduce, reverse, repeat,
  skip, tail, take, zip, zipWith
}

let head [x :: _]  = x


let tail [_ :: xs] = xs


let map list f =
  let
    map_ acc [] _ =
      reverse acc

    map_ acc [x :: xs] f =
      map_ [f x :: acc] xs f
  in
    map_ [] list f


let count list =
  let
    count_ acc [] =
      acc

    count_ acc [_ :: xs] =
      count_ (acc + 1) xs
  in
    count_ 0 list


let countBy list fn =
  let
    countBy_ acc [] =
      acc

    countBy_ acc [x :: xs] =
      countBy_ (acc + (fn x)) xs
  in
    countBy_ 0 list


let isEmpty [] = true
let isEmpty _  = false


let filter list fn =
  let
    filter_ acc [] _ =
      reverse acc

    filter_ acc [x :: xs] fn =
      if (fn x) then
        (filter_ [x :: acc] xs fn)
      else
        (filter_ acc xs fn)
  in
    filter_ [] list fn


let groupBy list fn =
  let
    groupBy_ acc [] _ =
      acc
      |> Map.mapValues ^List.reverse

    groupBy_ groups [x :: xs] fn =
      groups
      |> Map.insertOrUpdate (fn x) [x] (group -> [x :: group])
      |> groupBy_ xs fn
  in
    groupBy_ {} list fn


let reduce [] acc f =
  acc
let reduce [x :: xs] acc f =
  reduce xs (f x acc) f


let reverse list =
  let
    reverse_ acc [] =
      acc
    reverse_ acc [x :: xs] =
      reverse_ [x :: acc] xs
  in
    reverse_ [] list


let skip list 0 =
  list
let skip [x :: xs] n =
  skip xs (n - 1)


let take list n =
  let
    take_ acc _ 0 =
      reverse acc

    take_ acc [] _ =
      reverse acc

    take_ acc [x :: xs] n =
      take_ [x :: acc] xs (n - 1)
  in
    take_ [] list n


let repeat iterations fn =
  repeat_ [] iterations 0 fn

let repeat_ acc max n fn =
  let
    values = [fn n :: acc]
  in
    if (n == (max - 1)) then
      (reverse values)
    else
      (repeat_ values max (n + 1) fn)


let zip xs ys =
  let
    zip_ acc [] _ =
      reverse acc

    zip_ acc _ [] =
      reverse acc

    zip_ acc [x :: xs] [y :: ys] =
      zip_ [{x, y} :: acc] xs ys
  in
    zip_ [] xs ys


let zip3 xs ys zs =
  let
    zip3_ acc [] _ _ =
      reverse acc

    zip3_ acc _ [] _ =
      reverse acc

    zip3_ acc _ _ [] =
      reverse acc

    zip3_ acc [x :: xs] [y :: ys] [z :: zs] =
      zip3_ [{x, y, z} :: acc] xs ys zs
  in
    zip3_ [] xs ys zs


let zip4 ws xs ys zs =
  let
    zip4_ acc [] _ _ _ =
      reverse acc

    zip4_ acc _ [] _ _ =
      reverse acc

    zip4_ acc _ _ [] _ =
      reverse acc

    zip4_ acc _ _ _ [] =
      reverse acc

    zip4_ acc [w :: ws] [x :: xs] [y :: ys] [z :: zs] =
      zip4_ [{w, x, y, z} :: acc] ws xs ys zs
  in
    zip4_ [] ws xs ys zs


let zipWith xs ys fn =
  let
    zipWith_ acc [] _ _ =
      reverse acc

    zipWith_ acc _ [] _ =
      reverse acc

    zipWith_ acc [x :: xs] [y :: ys] fn =
      zipWith_ [fn x y :: acc] xs ys fn
  in
    zipWith_ [] xs ys fn


let all list fn =
  let
    all_ acc [] _ =
      acc

    all_ acc [x :: xs] fn =
      if (fn x) then
        (all_ true xs fn)
      else
        false
  in
    all_ true list fn


let any list fn =
  let
    any_ acc [] _ =
      acc

    any_ acc [x :: xs] fn =
      if (fn x) then
        true
      else
        (any_ false xs fn)
  in
    (any_ false list fn)
